### 简介
> 事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)
  一个完整的业务会执行多条SQL语句，要么全部执行成功，要么全部执行失败。

### 事物四大特性

- **原子性**

  事务是最小单元，不可再分，要么全部执行成功，要么全部失败回滚

- **一致性**

  一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。**不一致性**包含三点：脏读，不可重复读，幻读

- **隔离性**

  隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离

- **持久性**

  对数据的修改是永久性的

### 事物隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|-----|-----|-----|-----|
| 读未提交(Read uncommitted) | 可能 | 可能 | 可能 |
| 读已提交(Read committed) | 不可能 | 可能 | 可能 |
| 可重复读(Repeatable read) | 不可能 | 不可能 | 可能 |
| 串行化(Serializable) | 不可能 | 不可能 | 不可能 |

从上往下，隔离强度逐渐增强，性能逐渐变差。其中，**可重复读**是 MySQL 的默认级别。

- ** 读未提交：read uncommitted **

> 
- 事物A和事物B, 事物A未提交的数据, 事物B可以读取到, 这就会导致脏读.
- 脏读: 脏读就是读到了别的事务回滚前的脏数据. 比如事务B执行过程中修改了数据X, 在未提交前，事务A读取了X, 而事务B却回滚了, 这样事务A就形成了脏读.
- 这种隔离级别最低, 这种级别一般是在理论上存在, 数据库隔离级别一般都高于该级别.

- ** 读已提交Read committed **

> - 事物A和事物B, 事物A提交的数据，事物B才能读取到.
- 这种级别可以避免“脏数据”, 但会导致“不可重复读取”.
- 不可重复读: 事务A首先读取了一条数据, 然后执行逻辑的时候，事务B将这条数据改变了, 然后事务A再次读取的时候, 发现数据不匹配了, 就是所谓的不可重复读了.
- Oracle默认隔离级别.

- ** 可重复读Repeatable read **

> - 事务A和事务B，事务A提交之后的数据, 事务B读取不到, 事务B是可重复读取数据.
- 这种隔离级别可以避免“不可重复读取”, 但是会导致“幻像读”.
- 幻读: 事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读.
- MySQL默认级别.

- ** 串行化Serializable **

> - 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发

不可重复读和幻读比较：
两者有些相似，但是前者针对的是update或delete，后者针对的insert。

### 事务提交和回滚原理
- 为了保证数据的持久性，数据库在执行SQL操作数据之前会先记录redo log和undo log
- redo log是重做日志，是用来恢复数据的，用于保障已提交事务的持久化特性
- undo log是回滚日志，记录事务修改之前版本的数据信息，用来回滚数据的用于保障 未提交事务的原子性
- redo/undo log都是写先写到日志缓冲区，再通过缓冲区写到磁盘日志文件中进行持久化保存
- undo日志还有一个用途就是用来控制数据的多版本（MVCC）

** redo log *

** undo log **


### 如何解决幻读

** 多版本并发控制MVCC (MultiVersion Concurrency Control) **
> InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。